# GIT-Helix-Processor: Registra API en entorno UAT
#
# Recibe payload estándar desde cualquier [Vendor]-Processor
# y registra el API en el repositorio de dominio correspondiente.
#
# Flujo MVP:
# 1. Recibe payload con datos del API
# 2. Clona el repositorio de dominio
# 3. Crea estructura de carpetas si no existe
# 4. Guarda el artefacto del API
# 5. Commit y push a main (MVP simplificado)
#
# Futuro: Crear rama efímera, PR, esperar aprobación Helix

name: Register API in UAT

on:
  workflow_dispatch:
    inputs:
      api_name:
        description: 'Nombre del API'
        required: true
        type: string
      api_version:
        description: 'Versión del API (ej: 1.0.0)'
        required: true
        type: string
      domain:
        description: 'Dominio del API'
        required: true
        type: string
      subdomain:
        description: 'Subdominio del API'
        required: true
        type: string
      invoker:
        description: 'Usuario que dispara la acción'
        required: true
        type: string
      # TODO: Añadir artifact_base64 cuando integremos con WSO2 real

env:
  TARGET_REPO: ${{ inputs.domain }}-${{ inputs.subdomain }}
  # Para MVP, asumimos que el repo está en la misma org/usuario
  TARGET_REPO_FULL: ${{ github.repository_owner }}/${{ inputs.domain }}-${{ inputs.subdomain }}

jobs:
  register-api:
    name: Registrar API en UAT
    runs-on: ubuntu-latest

    steps:
      - name: Log solicitud recibida
        run: |
          echo "=========================================="
          echo "Solicitud de registro en UAT"
          echo "=========================================="
          echo "API: ${{ inputs.api_name }}"
          echo "Versión: ${{ inputs.api_version }}"
          echo "Dominio: ${{ inputs.domain }}"
          echo "Subdominio: ${{ inputs.subdomain }}"
          echo "Usuario: ${{ inputs.invoker }}"
          echo "Repo destino: ${{ env.TARGET_REPO_FULL }}"
          echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "=========================================="

      - name: Calcular versión corta
        id: version
        run: |
          # Convertir 1.0.0 -> v1.0
          FULL_VERSION="${{ inputs.api_version }}"
          SHORT_VERSION="v$(echo $FULL_VERSION | cut -d. -f1,2)"
          echo "short=$SHORT_VERSION" >> $GITHUB_OUTPUT
          echo "Versión corta: $SHORT_VERSION"

      - name: Clonar repositorio de dominio
        run: |
          echo "Clonando ${{ env.TARGET_REPO_FULL }}..."

          # TODO: Usar GIT_BOT_TOKEN para repos privados
          # git clone https://x-access-token:${{ secrets.GIT_BOT_TOKEN }}@github.com/${{ env.TARGET_REPO_FULL }}.git domain-repo

          # MVP: Simulamos el clone
          mkdir -p domain-repo
          cd domain-repo
          git init
          echo "# ${{ env.TARGET_REPO }}" > README.md
          git add .
          git commit -m "init" --allow-empty

          echo ">>> SIMULACIÓN: Repo clonado <<<"

      - name: Crear estructura de carpetas
        run: |
          cd domain-repo

          # Estructura: apis/{api-name}/{version}/uat/
          API_PATH="apis/${{ inputs.api_name }}/${{ steps.version.outputs.short }}/uat"

          echo "Creando estructura: $API_PATH"
          mkdir -p "$API_PATH/Artifact"
          mkdir -p "$API_PATH/Conf"

          # Crear archivo de metadata
          cat > "$API_PATH/metadata.json" << EOF
          {
            "api_name": "${{ inputs.api_name }}",
            "version": "${{ inputs.api_version }}",
            "version_short": "${{ steps.version.outputs.short }}",
            "environment": "uat",
            "registered_by": "${{ inputs.invoker }}",
            "registered_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "source_workflow": "${{ github.run_id }}"
          }
          EOF

          echo "Estructura creada:"
          find apis -type f

      - name: Guardar artefacto del API
        run: |
          cd domain-repo
          API_PATH="apis/${{ inputs.api_name }}/${{ steps.version.outputs.short }}/uat"

          # TODO: Cuando tengamos el ZIP real desde WSO2
          # echo "${{ inputs.artifact_base64 }}" | base64 -d > "$API_PATH/Artifact/${{ inputs.api_name }}_${{ inputs.api_version }}.zip"

          # MVP: Crear archivo placeholder
          cat > "$API_PATH/Artifact/placeholder.txt" << EOF
          Este archivo será reemplazado por el ZIP real del API exportado desde WSO2.

          API: ${{ inputs.api_name }}
          Versión: ${{ inputs.api_version }}
          Fecha: $(date -u +%Y-%m-%dT%H:%M:%SZ)
          EOF

          # Crear params.yaml de ejemplo para UAT
          cat > "$API_PATH/Conf/params-uat.yaml" << EOF
          # Configuración específica para UAT
          # Este archivo se fusionará con el API exportado

          environments:
            - name: uat
              configs:
                endpoints:
                  production:
                    url: https://api-uat.example.com/${{ inputs.api_name | lower }}
                  sandbox:
                    url: https://api-uat-sandbox.example.com/${{ inputs.api_name | lower }}
                deploymentEnvironments:
                  - displayOnDevportal: true
                    deploymentEnvironment: UAT-Gateway
                policies:
                  - Gold
          EOF

          echo "Artefactos guardados:"
          ls -la "$API_PATH/Artifact/"
          ls -la "$API_PATH/Conf/"

      - name: Commit y push
        run: |
          cd domain-repo

          git config user.name "git-helix-bot"
          git config user.email "git-helix-bot@example.com"

          git add .
          git status

          COMMIT_MSG="feat(uat): register ${{ inputs.api_name }} ${{ steps.version.outputs.short }}

          Registered by: ${{ inputs.invoker }}
          Source: GIT-Helix-Processor workflow
          Run ID: ${{ github.run_id }}"

          git commit -m "$COMMIT_MSG"

          echo ""
          echo ">>> SIMULACIÓN: Se haría push a ${{ env.TARGET_REPO_FULL }} <<<"
          echo ""
          echo "Commit creado:"
          git log -1 --oneline

          # TODO: Push real
          # git push origin main

      - name: Notificar resultado
        run: |
          echo ""
          echo "=========================================="
          echo "REGISTRO COMPLETADO (Simulación MVP)"
          echo "=========================================="
          echo ""
          echo "El API ${{ inputs.api_name }} ${{ steps.version.outputs.short }}"
          echo "ha sido registrado en UAT en el repositorio"
          echo "${{ env.TARGET_REPO_FULL }}"
          echo ""
          echo "Estructura creada:"
          echo "  apis/${{ inputs.api_name }}/${{ steps.version.outputs.short }}/uat/"
          echo "    ├── Artifact/"
          echo "    ├── Conf/params-uat.yaml"
          echo "    └── metadata.json"
          echo ""

      - name: Resumen
        run: |
          echo "## API Registrado en UAT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Campo | Valor |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| API | ${{ inputs.api_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Versión | ${{ inputs.api_version }} (${{ steps.version.outputs.short }}) |" >> $GITHUB_STEP_SUMMARY
          echo "| Entorno | UAT |" >> $GITHUB_STEP_SUMMARY
          echo "| Repositorio | ${{ env.TARGET_REPO_FULL }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Registrado por | ${{ inputs.invoker }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Estado | Completado (Simulación) |" >> $GITHUB_STEP_SUMMARY
