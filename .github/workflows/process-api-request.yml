# =============================================================================
# apim-apiops-controller: Motor Central de Procesamiento de APIs
# =============================================================================
#
# PROPÓSITO:
#   Motor central vendor-agnostic que recibe solicitudes de registro de APIs
#   desde extractores (apim-exporter-wso2, etc.) y las procesa con integración ITSM.
#
# FLUJO:
#   1. Recibe solicitud de un extractor (apim-exporter-wso2, etc.)
#   2. Valida que el subdominio exista en repo-config.yaml
#   3. Crea Issue como "cola" de solicitudes pendientes
#   4. Guarda artifact con el export de la API (30 días retención)
#   5. Crea CRQ en Helix ITSM (simulado por ahora)
#   6. Si AUTO_APPROVE=true, dispara on-helix-approval.yml automáticamente
#
# CONFIGURACIÓN REQUERIDA (GitHub Secrets):
#   - GIT_HELIX_PAT: Token con permisos repo, workflow (para dispatches)
#
# VARIABLES DE REPOSITORIO (Settings > Variables):
#   - AUTO_APPROVE: "true" para testing, "false" para producción
#                   (Por defecto: false si no se configura)
#
# Para simular aprobación manual de Helix:
#   gh api repos/OWNER/apim-apiops-controller/dispatches \
#     -f event_type=helix-approval \
#     -f client_payload='{"crq_id":"CRQ-xxx","status":"APPROVED","request_id":"REQ-xxx"}'
#
# =============================================================================
name: Process API Request

on:
  workflow_dispatch:
    inputs:
      requestId:
        description: 'Unique Request ID for correlation (REQ-xxx-xxx)'
        required: false
        type: string
        default: ''
      subdominio:
        description: 'Subdominio de la API'
        required: true
        type: string
      apiName:
        description: 'Nombre de la API'
        required: true
        type: string
      apiVersion:
        description: 'Version de la API'
        required: true
        type: string
      apiContext:
        description: 'Context path de la API'
        required: false
        type: string
        default: ''
      revisionId:
        description: 'Revision ID from WSO2 (number)'
        required: false
        type: string
        default: '1'
      backendUrl:
        description: 'URL del backend'
        required: false
        type: string
        default: ''
      apiExportZip:
        description: 'ZIP completo del export de apictl (base64)'
        required: true
        type: string
      sourceSystem:
        description: 'Sistema origen (wso2, apigee, kong...)'
        required: false
        type: string
        default: 'wso2'
      userId:
        description: 'Usuario solicitante'
        required: false
        type: string
        default: 'unknown'

env:
  # Archivo de configuración de subdominios
  CONFIG_FILE: repo-config.yaml
  # Límites de retención (para futuras implementaciones de limpieza)
  MAX_VERSIONS: "4"
  MAX_REVISIONS: "4"
  # Feature flag: auto-aprobar para testing (configurar como variable de repo)
  # En producción: Settings > Variables > AUTO_APPROVE = "false"
  AUTO_APPROVE: ${{ vars.AUTO_APPROVE || 'false' }}

# Permissions required for creating Issues and artifacts
permissions:
  contents: read
  issues: write
  actions: write

jobs:
  process-request:
    name: Process API Registration
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Helix-Processor
        uses: actions/checkout@v4

      - name: Generate Request ID
        id: request-id
        run: |
          if [ -n "${{ inputs.requestId }}" ]; then
            REQUEST_ID="${{ inputs.requestId }}"
          else
            # Generate: REQ-{api-short}-{timestamp}-{random}
            API_SHORT=$(echo "${{ inputs.apiName }}" | cut -c1-8 | tr '[:upper:]' '[:lower:]')
            TIMESTAMP=$(date +%s | cut -c6-10)
            RANDOM_PART=$(echo $RANDOM | md5sum | cut -c1-4)
            REQUEST_ID="REQ-${API_SHORT}-${TIMESTAMP}-${RANDOM_PART}"
          fi
          echo "request_id=${REQUEST_ID}" >> $GITHUB_OUTPUT
          echo "Request ID: ${REQUEST_ID}"

      # -----------------------------------------------------------------------
      # Paso 2: Log de la solicitud
      # -----------------------------------------------------------------------
      - name: Log Request
        run: |
          echo "::notice title=API Request::${{ inputs.apiName }} v${{ inputs.apiVersion }} from ${{ inputs.sourceSystem }}"
          echo "Request ID:  ${{ steps.request-id.outputs.request_id }}"
          echo "Subdominio:  ${{ inputs.subdominio }}"
          echo "Revision:    ${{ inputs.revisionId }}"
          echo "User:        ${{ inputs.userId }}"

      # -----------------------------------------------------------------------
      # Paso 3: Validar que el subdominio existe en la configuración
      # -----------------------------------------------------------------------
      - name: Validate Subdominio Exists
        id: validate
        run: |
          SUBDOMINIO="${{ inputs.subdominio }}"

          if ! grep -q "^  ${SUBDOMINIO}:" ${{ env.CONFIG_FILE }}; then
            AVAILABLE=$(grep -E "^  [a-z]" ${{ env.CONFIG_FILE }} | grep ":" | sed 's/://g' | sed 's/^ *//' | tr '\n' ', ')
            echo "::error title=Subdominio inválido::El subdominio '$SUBDOMINIO' no está configurado. Disponibles: ${AVAILABLE}"
            exit 1
          fi

          # Extraer git_repo del subdominio
          GIT_REPO=$(awk "/^  ${SUBDOMINIO}:/{found=1} found && /git_repo:/{print \$2; exit}" ${{ env.CONFIG_FILE }} | tr -d '"')

          if [ -z "$GIT_REPO" ]; then
            echo "::error::No se encontró git_repo para subdominio '$SUBDOMINIO' en ${{ env.CONFIG_FILE }}"
            exit 1
          fi

          echo "::notice::Subdominio validado: $SUBDOMINIO → $GIT_REPO"
          echo "git_repo=${GIT_REPO}" >> $GITHUB_OUTPUT

      # -----------------------------------------------------------------------
      # Paso 4: Parsear Revision ID
      # -----------------------------------------------------------------------
      - name: Set Revision ID
        id: revision-id
        run: |
          WSO2_REV="${{ inputs.revisionId }}"
          REV_NUM=$(echo "$WSO2_REV" | grep -oE '^[0-9]+$' || echo "1")
          REVISION_ID="rev-${REV_NUM}"
          echo "revision_id=${REVISION_ID}" >> $GITHUB_OUTPUT
          echo "revision_num=${REV_NUM}" >> $GITHUB_OUTPUT

      # -----------------------------------------------------------------------
      # Paso 5: Decodificar y extraer el export de la API
      # -----------------------------------------------------------------------
      - name: Decode and Extract API Export
        id: extract
        run: |
          mkdir -p ./api-export
          echo "${{ inputs.apiExportZip }}" | base64 -d > ./api-export/export.zip
          unzip -q ./api-export/export.zip -d ./api-export/extracted
          API_DIR=$(find ./api-export/extracted -type d -mindepth 1 -maxdepth 1 | head -1)
          echo "api_dir=${API_DIR}" >> $GITHUB_OUTPUT
          echo "::notice::API export extraído: $(ls "$API_DIR" | wc -l) archivos"

      # -----------------------------------------------------------------------
      # Paso 6: Validaciones de calidad (futuro: Spectral, seguridad, etc.)
      # -----------------------------------------------------------------------
      - name: Run Linters
        run: |
          # TODO: Integrar validaciones
          # - Spectral para OpenAPI
          # - Validaciones de seguridad (OWASP)
          # - Validaciones de naming conventions
          echo "::notice::Linters: SKIP (no configurados)"

      # -----------------------------------------------------------------------
      # Paso 7: Crear Issue como "cola" de solicitudes pendientes
      # -----------------------------------------------------------------------
      - name: Create Pending Request Issue
        id: create-issue
        env:
          GH_TOKEN: ${{ secrets.GIT_HELIX_PAT }}
        run: |
          REQUEST_ID="${{ steps.request-id.outputs.request_id }}"
          API_NAME="${{ inputs.apiName }}"
          API_VERSION="${{ inputs.apiVersion }}"
          REVISION_ID="${{ steps.revision-id.outputs.revision_id }}"
          SUBDOMINIO="${{ inputs.subdominio }}"
          USER_ID="${{ inputs.userId }}"
          BACKEND_URL="${{ inputs.backendUrl }}"
          API_CONTEXT="${{ inputs.apiContext }}"
          TARGET_REPO="${{ steps.validate.outputs.git_repo }}"

          # Check if issue already exists for this request
          EXISTING=$(gh issue list --label "pending-helix" --search "${REQUEST_ID} in:title" --json number --jq '.[0].number // empty')

          if [ -n "$EXISTING" ]; then
            echo "Issue #${EXISTING} already exists for ${REQUEST_ID}"
            echo "issue_number=${EXISTING}" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Create issue with metadata in body (YAML format for easy parsing)
          ISSUE_BODY=$(cat <<EOF
          # Pending Helix Approval

          ## Request Details
          | Campo | Valor |
          |-------|-------|
          | Request ID | ${REQUEST_ID} |
          | API | ${API_NAME} v${API_VERSION} |
          | Revision | ${REVISION_ID} |
          | Subdominio | ${SUBDOMINIO} |
          | Target Repo | ${TARGET_REPO} |
          | User | ${USER_ID} |
          | Source | ${{ inputs.sourceSystem }} |
          | Workflow | https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }} |

          ## Metadata (do not edit)
          \`\`\`yaml
          request_id: ${REQUEST_ID}
          api_name: ${API_NAME}
          api_version: ${API_VERSION}
          revision_id: ${REVISION_ID}
          subdominio: ${SUBDOMINIO}
          target_repo: ${TARGET_REPO}
          user_id: ${USER_ID}
          backend_url: ${BACKEND_URL}
          api_context: ${API_CONTEXT}
          source_system: ${{ inputs.sourceSystem }}
          \`\`\`

          ---
          **Estado**: Esperando aprobación de Helix ITSM

          Cuando Helix apruebe el CRQ, enviará un webhook y esta solicitud será procesada automáticamente.
          EOF
          )

          ISSUE_URL=$(gh issue create \
            --title "UAT Request: ${API_NAME} v${API_VERSION} [${REQUEST_ID}]" \
            --body "$ISSUE_BODY" \
            --label "pending-helix")

          ISSUE_NUMBER=$(echo "$ISSUE_URL" | grep -oE '[0-9]+$')

          echo "Created Issue #${ISSUE_NUMBER}"
          echo "issue_number=${ISSUE_NUMBER}" >> $GITHUB_OUTPUT
          echo "issue_url=${ISSUE_URL}" >> $GITHUB_OUTPUT

      # -----------------------------------------------------------------------
      # Paso 8: Guardar artifact para cuando Helix apruebe
      # -----------------------------------------------------------------------
      - name: Save API Export Artifact
        uses: actions/upload-artifact@v4
        with:
          name: api-export-${{ steps.request-id.outputs.request_id }}
          path: ./api-export/extracted/
          retention-days: 30

      # -----------------------------------------------------------------------
      # Paso 9: Crear CRQ en Helix ITSM (simulado por ahora)
      # -----------------------------------------------------------------------
      - name: Create Helix CRQ
        id: helix
        env:
          GH_TOKEN: ${{ secrets.GIT_HELIX_PAT }}
        run: |
          REQUEST_ID="${{ steps.request-id.outputs.request_id }}"
          ISSUE_NUMBER="${{ steps.create-issue.outputs.issue_number }}"

          echo "=========================================="
          echo "  Creando CRQ en Helix ITSM"
          echo "=========================================="

          # TODO: Integración real con Helix API
          # Aquí se llamaría a la API de Helix para crear el CRQ
          # El CRQ incluiría el callback URL para el webhook

          CRQ_ID="CRQ-$(date +%Y%m%d%H%M%S)"

          echo "API: ${{ inputs.apiName }} v${{ inputs.apiVersion }}"
          echo "Subdominio: ${{ inputs.subdominio }}"
          echo "Solicitante: ${{ inputs.userId }}"
          echo ""
          echo "CRQ creado: ${CRQ_ID}"
          echo "Estado: PENDING (esperando aprobación)"

          # Update issue with CRQ ID
          gh issue comment "${ISSUE_NUMBER}" \
            --body "## CRQ Creado en Helix

          | Campo | Valor |
          |-------|-------|
          | CRQ ID | ${CRQ_ID} |
          | Estado | PENDING |

          Esperando aprobación del Change Advisory Board..."

          echo "crq_id=${CRQ_ID}" >> $GITHUB_OUTPUT

      # -----------------------------------------------------------------------
      # Paso 10: Auto-aprobar para testing (solo si AUTO_APPROVE=true)
      # -----------------------------------------------------------------------
      - name: Simulate Helix Approval (Testing Only)
        if: env.AUTO_APPROVE == 'true'
        env:
          GH_TOKEN: ${{ secrets.GIT_HELIX_PAT }}
        run: |
          REQUEST_ID="${{ steps.request-id.outputs.request_id }}"
          CRQ_ID="${{ steps.helix.outputs.crq_id }}"

          echo "=========================================="
          echo "  SIMULACIÓN: Auto-aprobando para testing"
          echo "=========================================="
          echo ""
          echo "En producción, este paso no existiría."
          echo "Helix enviaría un webhook cuando el CRQ sea aprobado."
          echo ""

          # Simular el webhook que enviaría Helix
          echo "Simulando webhook de Helix..."

          # Usar curl para enviar el dispatch con JSON correcto
          curl -s -X POST \
            -H "Authorization: token ${GH_TOKEN}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/dispatches" \
            -d "{\"event_type\":\"helix-approval\",\"client_payload\":{\"crq_id\":\"${CRQ_ID}\",\"status\":\"APPROVED\",\"request_id\":\"${REQUEST_ID}\"}}"

          echo ""
          echo "Webhook simulado enviado."
          echo "El workflow 'On Helix Approval' procesará la solicitud."

      - name: Summary
        run: |
          echo "## API Request Queued" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Campo | Valor |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Request ID | ${{ steps.request-id.outputs.request_id }} |" >> $GITHUB_STEP_SUMMARY
          echo "| API | ${{ inputs.apiName }} v${{ inputs.apiVersion }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Revision | ${{ steps.revision-id.outputs.revision_id }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Subdominio | ${{ inputs.subdominio }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Helix CRQ | ${{ steps.helix.outputs.crq_id }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Issue | #${{ steps.create-issue.outputs.issue_number }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Estado | Pending Helix Approval |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "La solicitud está en cola esperando aprobación de Helix ITSM." >> $GITHUB_STEP_SUMMARY
          if [ "${{ env.AUTO_APPROVE }}" == "true" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**NOTA**: Auto-aprobación habilitada para testing." >> $GITHUB_STEP_SUMMARY
          fi
