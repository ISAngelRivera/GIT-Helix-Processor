# =============================================================================
# GIT-Helix-Processor: Motor Central de Procesamiento de APIs
# =============================================================================
# NUEVO FLUJO CON WEBHOOK:
# 1. Recibe solicitud de WSO2-Processor
# 2. Valida subdominio y datos
# 3. Crea Issue como "cola" de solicitudes pendientes
# 4. Guarda artifact con el export de la API
# 5. Crea CRQ en Helix ITSM (simulado por ahora)
# 6. Termina - NO crea PR directamente
#
# Cuando Helix aprueba, envía webhook → on-helix-approval.yml crea la PR
#
# Para simular la aprobación de Helix (testing), ejecutar:
#   gh api repos/OWNER/GIT-Helix-Processor/dispatches \
#     -f event_type=helix-approval \
#     -f client_payload='{"crq_id":"CRQ-xxx","status":"APPROVED","request_id":"REQ-xxx"}'
# =============================================================================
name: Process API Request

on:
  workflow_dispatch:
    inputs:
      requestId:
        description: 'Unique Request ID for correlation (REQ-xxx-xxx)'
        required: false
        type: string
        default: ''
      subdominio:
        description: 'Subdominio de la API'
        required: true
        type: string
      apiName:
        description: 'Nombre de la API'
        required: true
        type: string
      apiVersion:
        description: 'Version de la API'
        required: true
        type: string
      apiContext:
        description: 'Context path de la API'
        required: false
        type: string
        default: ''
      revisionId:
        description: 'Revision ID from WSO2 (number)'
        required: false
        type: string
        default: '1'
      backendUrl:
        description: 'URL del backend'
        required: false
        type: string
        default: ''
      apiExportZip:
        description: 'ZIP completo del export de apictl (base64)'
        required: true
        type: string
      sourceSystem:
        description: 'Sistema origen (wso2, apigee, kong...)'
        required: false
        type: string
        default: 'wso2'
      userId:
        description: 'Usuario solicitante'
        required: false
        type: string
        default: 'unknown'

env:
  CONFIG_FILE: repo-config.yaml
  MAX_VERSIONS: "4"
  MAX_REVISIONS: "4"
  # Feature flag: si true, simula aprobación automática (para testing)
  AUTO_APPROVE: "true"

# Permissions required for creating Issues and artifacts
permissions:
  contents: read
  issues: write
  actions: write

jobs:
  process-request:
    name: Process API Registration
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Helix-Processor
        uses: actions/checkout@v4

      - name: Generate Request ID
        id: request-id
        run: |
          if [ -n "${{ inputs.requestId }}" ]; then
            REQUEST_ID="${{ inputs.requestId }}"
          else
            # Generate: REQ-{api-short}-{timestamp}-{random}
            API_SHORT=$(echo "${{ inputs.apiName }}" | cut -c1-8 | tr '[:upper:]' '[:lower:]')
            TIMESTAMP=$(date +%s | cut -c6-10)
            RANDOM_PART=$(echo $RANDOM | md5sum | cut -c1-4)
            REQUEST_ID="REQ-${API_SHORT}-${TIMESTAMP}-${RANDOM_PART}"
          fi
          echo "request_id=${REQUEST_ID}" >> $GITHUB_OUTPUT
          echo "Request ID: ${REQUEST_ID}"

      - name: Log Request
        run: |
          echo "=========================================="
          echo "  API Registration Request"
          echo "=========================================="
          echo "Request ID:  ${{ steps.request-id.outputs.request_id }}"
          echo "Subdominio:  ${{ inputs.subdominio }}"
          echo "API:         ${{ inputs.apiName }} v${{ inputs.apiVersion }}"
          echo "Revision:    ${{ inputs.revisionId }}"
          echo "Context:     ${{ inputs.apiContext }}"
          echo "Source:      ${{ inputs.sourceSystem }}"
          echo "User:        ${{ inputs.userId }}"
          echo "=========================================="

      - name: Validate Subdominio Exists
        id: validate
        run: |
          SUBDOMINIO="${{ inputs.subdominio }}"

          if ! grep -q "^  ${SUBDOMINIO}:" ${{ env.CONFIG_FILE }}; then
            echo "=========================================="
            echo "  ERROR: Subdominio '$SUBDOMINIO' no existe"
            echo "=========================================="
            echo ""
            echo "Subdominios disponibles:"
            grep -E "^  [a-z]" ${{ env.CONFIG_FILE }} | grep ":" | sed 's/://g' | sed 's/^ */  - /'
            echo ""
            exit 1
          fi

          # Extraer git_repo del subdominio
          GIT_REPO=$(awk "/^  ${SUBDOMINIO}:/{found=1} found && /git_repo:/{print \$2; exit}" ${{ env.CONFIG_FILE }} | tr -d '"')

          if [ -z "$GIT_REPO" ]; then
            echo "ERROR: No se encontro git_repo para subdominio '$SUBDOMINIO'"
            exit 1
          fi

          echo "Subdominio validado: $SUBDOMINIO"
          echo "Target repo: $GIT_REPO"
          echo "git_repo=${GIT_REPO}" >> $GITHUB_OUTPUT

      - name: Set Revision ID
        id: revision-id
        run: |
          WSO2_REV="${{ inputs.revisionId }}"
          REV_NUM=$(echo "$WSO2_REV" | grep -oE '^[0-9]+$' || echo "1")
          REVISION_ID="rev-${REV_NUM}"
          echo "revision_id=${REVISION_ID}" >> $GITHUB_OUTPUT
          echo "revision_num=${REV_NUM}" >> $GITHUB_OUTPUT
          echo "Revision ID: ${REVISION_ID}"

      - name: Decode and Extract API Export
        id: extract
        run: |
          echo "Decoding API export ZIP..."
          mkdir -p ./api-export

          # Decodificar el ZIP
          echo "${{ inputs.apiExportZip }}" | base64 -d > ./api-export/export.zip

          # Descomprimir
          unzip -q ./api-export/export.zip -d ./api-export/extracted

          # Encontrar directorio de la API
          API_DIR=$(find ./api-export/extracted -type d -mindepth 1 -maxdepth 1 | head -1)
          echo "api_dir=${API_DIR}" >> $GITHUB_OUTPUT

          echo "Contenido extraido:"
          ls -la "$API_DIR"

      - name: Run Linters
        run: |
          echo "TODO: Ejecutar linters (Spectral, validaciones de seguridad...)"
          echo "Por ahora: SKIP"

      # =========================================
      # Crear Issue como "cola" de solicitudes
      # =========================================
      - name: Create Pending Request Issue
        id: create-issue
        env:
          GH_TOKEN: ${{ secrets.GIT_HELIX_PAT }}
        run: |
          REQUEST_ID="${{ steps.request-id.outputs.request_id }}"
          API_NAME="${{ inputs.apiName }}"
          API_VERSION="${{ inputs.apiVersion }}"
          REVISION_ID="${{ steps.revision-id.outputs.revision_id }}"
          SUBDOMINIO="${{ inputs.subdominio }}"
          USER_ID="${{ inputs.userId }}"
          BACKEND_URL="${{ inputs.backendUrl }}"
          API_CONTEXT="${{ inputs.apiContext }}"
          TARGET_REPO="${{ steps.validate.outputs.git_repo }}"

          # Check if issue already exists for this request
          EXISTING=$(gh issue list --label "pending-helix" --search "${REQUEST_ID} in:title" --json number --jq '.[0].number // empty')

          if [ -n "$EXISTING" ]; then
            echo "Issue #${EXISTING} already exists for ${REQUEST_ID}"
            echo "issue_number=${EXISTING}" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Create issue with metadata in body (YAML format for easy parsing)
          ISSUE_BODY=$(cat <<EOF
          # Pending Helix Approval

          ## Request Details
          | Campo | Valor |
          |-------|-------|
          | Request ID | ${REQUEST_ID} |
          | API | ${API_NAME} v${API_VERSION} |
          | Revision | ${REVISION_ID} |
          | Subdominio | ${SUBDOMINIO} |
          | Target Repo | ${TARGET_REPO} |
          | User | ${USER_ID} |
          | Source | ${{ inputs.sourceSystem }} |
          | Workflow | https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }} |

          ## Metadata (do not edit)
          \`\`\`yaml
          request_id: ${REQUEST_ID}
          api_name: ${API_NAME}
          api_version: ${API_VERSION}
          revision_id: ${REVISION_ID}
          subdominio: ${SUBDOMINIO}
          target_repo: ${TARGET_REPO}
          user_id: ${USER_ID}
          backend_url: ${BACKEND_URL}
          api_context: ${API_CONTEXT}
          source_system: ${{ inputs.sourceSystem }}
          \`\`\`

          ---
          **Estado**: Esperando aprobación de Helix ITSM

          Cuando Helix apruebe el CRQ, enviará un webhook y esta solicitud será procesada automáticamente.
          EOF
          )

          ISSUE_URL=$(gh issue create \
            --title "UAT Request: ${API_NAME} v${API_VERSION} [${REQUEST_ID}]" \
            --body "$ISSUE_BODY" \
            --label "pending-helix")

          ISSUE_NUMBER=$(echo "$ISSUE_URL" | grep -oE '[0-9]+$')

          echo "Created Issue #${ISSUE_NUMBER}"
          echo "issue_number=${ISSUE_NUMBER}" >> $GITHUB_OUTPUT
          echo "issue_url=${ISSUE_URL}" >> $GITHUB_OUTPUT

      # =========================================
      # Guardar artifact para cuando Helix apruebe
      # =========================================
      - name: Save API Export Artifact
        uses: actions/upload-artifact@v4
        with:
          name: api-export-${{ steps.request-id.outputs.request_id }}
          path: ./api-export/extracted/
          retention-days: 30

      # =========================================
      # Crear CRQ en Helix (simulado)
      # =========================================
      - name: Create Helix CRQ
        id: helix
        env:
          GH_TOKEN: ${{ secrets.GIT_HELIX_PAT }}
        run: |
          REQUEST_ID="${{ steps.request-id.outputs.request_id }}"
          ISSUE_NUMBER="${{ steps.create-issue.outputs.issue_number }}"

          echo "=========================================="
          echo "  Creando CRQ en Helix ITSM"
          echo "=========================================="

          # TODO: Integración real con Helix API
          # Aquí se llamaría a la API de Helix para crear el CRQ
          # El CRQ incluiría el callback URL para el webhook

          CRQ_ID="CRQ-$(date +%Y%m%d%H%M%S)"

          echo "API: ${{ inputs.apiName }} v${{ inputs.apiVersion }}"
          echo "Subdominio: ${{ inputs.subdominio }}"
          echo "Solicitante: ${{ inputs.userId }}"
          echo ""
          echo "CRQ creado: ${CRQ_ID}"
          echo "Estado: PENDING (esperando aprobación)"

          # Update issue with CRQ ID
          gh issue comment "${ISSUE_NUMBER}" \
            --body "## CRQ Creado en Helix

          | Campo | Valor |
          |-------|-------|
          | CRQ ID | ${CRQ_ID} |
          | Estado | PENDING |

          Esperando aprobación del Change Advisory Board..."

          echo "crq_id=${CRQ_ID}" >> $GITHUB_OUTPUT

      # =========================================
      # SIMULACIÓN: Auto-aprobar para testing
      # =========================================
      - name: Simulate Helix Approval (Testing Only)
        if: env.AUTO_APPROVE == 'true'
        env:
          GH_TOKEN: ${{ secrets.GIT_HELIX_PAT }}
        run: |
          REQUEST_ID="${{ steps.request-id.outputs.request_id }}"
          CRQ_ID="${{ steps.helix.outputs.crq_id }}"

          echo "=========================================="
          echo "  SIMULACIÓN: Auto-aprobando para testing"
          echo "=========================================="
          echo ""
          echo "En producción, este paso no existiría."
          echo "Helix enviaría un webhook cuando el CRQ sea aprobado."
          echo ""

          # Simular el webhook que enviaría Helix
          echo "Simulando webhook de Helix..."

          # Usar curl para enviar el dispatch con JSON correcto
          curl -s -X POST \
            -H "Authorization: token ${GH_TOKEN}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/dispatches" \
            -d "{\"event_type\":\"helix-approval\",\"client_payload\":{\"crq_id\":\"${CRQ_ID}\",\"status\":\"APPROVED\",\"request_id\":\"${REQUEST_ID}\"}}"

          echo ""
          echo "Webhook simulado enviado."
          echo "El workflow 'On Helix Approval' procesará la solicitud."

      - name: Summary
        run: |
          echo "## API Request Queued" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Campo | Valor |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Request ID | ${{ steps.request-id.outputs.request_id }} |" >> $GITHUB_STEP_SUMMARY
          echo "| API | ${{ inputs.apiName }} v${{ inputs.apiVersion }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Revision | ${{ steps.revision-id.outputs.revision_id }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Subdominio | ${{ inputs.subdominio }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Helix CRQ | ${{ steps.helix.outputs.crq_id }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Issue | #${{ steps.create-issue.outputs.issue_number }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Estado | Pending Helix Approval |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "La solicitud está en cola esperando aprobación de Helix ITSM." >> $GITHUB_STEP_SUMMARY
          if [ "${{ env.AUTO_APPROVE }}" == "true" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**NOTA**: Auto-aprobación habilitada para testing." >> $GITHUB_STEP_SUMMARY
          fi
