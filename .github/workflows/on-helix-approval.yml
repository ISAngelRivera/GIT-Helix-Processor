# =============================================================================
# apim-apiops-controller: Receptor de Webhooks de Helix ITSM
# =============================================================================
#
# PROPÓSITO:
#   Recibe webhooks de Helix ITSM cuando un CRQ es aprobado o rechazado
#   y procesa la solicitud creando PR en el repo de dominio o cerrando el Issue.
#
# ESTRUCTURA SIMPLIFICADA (v3 - Sin Revisiones):
#   apis/{APIName}/
#     state.yaml                    # Estado por entorno (auto-generated)
#     {Version}/
#       api.yaml                    # Definición API (actualizada en cada registro)
#       Definitions/swagger.yaml    # Contrato OpenAPI
#       Conf/
#         api_meta.yaml             # Metadata deploy
#         params.yaml               # Config UAT/NFT/PRO
#         request.yaml              # Última solicitud (trazabilidad)
#
# FLUJO:
#   - Si la versión NO existe → Crear carpeta + archivos
#   - Si la versión YA existe → Sobrescribir (actualizar)
#
# =============================================================================
name: On Helix Approval

on:
  repository_dispatch:
    types: [helix-approval]

env:
  CONFIG_FILE: repo-config.yaml
  MAX_VERSIONS: "4"

permissions:
  contents: read
  issues: write
  actions: read

jobs:
  process-approval:
    name: "Process Helix ${{ github.event.client_payload.status }}: ${{ github.event.client_payload.crq_id }}"
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Helix-Processor
        uses: actions/checkout@v4

      # -----------------------------------------------------------------------
      # Paso 1: Validar payload del webhook
      # -----------------------------------------------------------------------
      - name: Validate Webhook Payload
        id: validate
        run: |
          CRQ_ID="${{ github.event.client_payload.crq_id }}"
          STATUS="${{ github.event.client_payload.status }}"
          REQUEST_ID="${{ github.event.client_payload.request_id }}"

          echo "::notice title=Helix Webhook::CRQ: ${CRQ_ID} | Status: ${STATUS} | Request: ${REQUEST_ID}"

          if [ -z "$CRQ_ID" ] || [ -z "$STATUS" ] || [ -z "$REQUEST_ID" ]; then
            echo "::error::Payload incompleto. Requeridos: crq_id, status, request_id"
            exit 1
          fi

          if [ "$STATUS" != "APPROVED" ] && [ "$STATUS" != "REJECTED" ]; then
            echo "::error::Status inválido '$STATUS'. Debe ser APPROVED o REJECTED"
            exit 1
          fi

          echo "crq_id=${CRQ_ID}" >> $GITHUB_OUTPUT
          echo "status=${STATUS}" >> $GITHUB_OUTPUT
          echo "request_id=${REQUEST_ID}" >> $GITHUB_OUTPUT

      # -----------------------------------------------------------------------
      # Paso 2: Buscar Issue pendiente con el request_id
      # -----------------------------------------------------------------------
      - name: Find Pending Request
        id: find-request
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          REQUEST_ID="${{ steps.validate.outputs.request_id }}"

          ISSUE=$(gh issue list \
            --label "pending-helix" \
            --search "${REQUEST_ID} in:title" \
            --json number,title,body \
            --jq '.[0]')

          if [ -z "$ISSUE" ] || [ "$ISSUE" == "null" ]; then
            echo "::error::No se encontró solicitud pendiente para ${REQUEST_ID}"
            exit 1
          fi

          ISSUE_NUMBER=$(echo "$ISSUE" | jq -r '.number')
          ISSUE_BODY=$(echo "$ISSUE" | jq -r '.body')

          echo "::notice::Encontrado Issue #${ISSUE_NUMBER}"

          # Extraer metadata del body del issue
          API_NAME=$(echo "$ISSUE_BODY" | grep "^api_name:" | cut -d: -f2 | tr -d ' ')
          API_VERSION=$(echo "$ISSUE_BODY" | grep "^api_version:" | cut -d: -f2 | tr -d ' ')
          SUBDOMINIO=$(echo "$ISSUE_BODY" | grep "^subdominio:" | cut -d: -f2 | tr -d ' ')
          USER_ID=$(echo "$ISSUE_BODY" | grep "^user_id:" | cut -d: -f2 | tr -d ' ')
          BACKEND_URL=$(echo "$ISSUE_BODY" | grep "^backend_url:" | cut -d: -f2- | tr -d ' ')
          ACTION=$(echo "$ISSUE_BODY" | grep "^action:" | cut -d: -f2 | tr -d ' ')
          ENVIRONMENT=$(echo "$ISSUE_BODY" | grep "^environment:" | cut -d: -f2 | tr -d ' ')

          # Default values
          [ -z "$ACTION" ] && ACTION="deploy"
          [ -z "$ENVIRONMENT" ] && ENVIRONMENT="uat"

          echo "issue_number=${ISSUE_NUMBER}" >> $GITHUB_OUTPUT
          echo "api_name=${API_NAME}" >> $GITHUB_OUTPUT
          echo "api_version=${API_VERSION}" >> $GITHUB_OUTPUT
          echo "subdominio=${SUBDOMINIO}" >> $GITHUB_OUTPUT
          echo "user_id=${USER_ID}" >> $GITHUB_OUTPUT
          echo "backend_url=${BACKEND_URL}" >> $GITHUB_OUTPUT
          echo "action=${ACTION}" >> $GITHUB_OUTPUT
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT

      # -----------------------------------------------------------------------
      # Paso 3a: Manejar RECHAZO - cerrar Issue
      # -----------------------------------------------------------------------
      - name: Handle Rejection
        if: steps.validate.outputs.status == 'REJECTED'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUMBER="${{ steps.find-request.outputs.issue_number }}"
          CRQ_ID="${{ steps.validate.outputs.crq_id }}"
          API_NAME="${{ steps.find-request.outputs.api_name }}"
          API_VERSION="${{ steps.find-request.outputs.api_version }}"

          echo "::warning::CRQ ${CRQ_ID} RECHAZADO"

          gh issue close "${ISSUE_NUMBER}" \
            --comment "## CRQ Rejected

          | Campo | Valor |
          |-------|-------|
          | CRQ | ${CRQ_ID} |
          | API | ${API_NAME} v${API_VERSION} |
          | Status | **REJECTED** |

          La solicitud ha sido rechazada por Helix ITSM."

          gh issue edit "${ISSUE_NUMBER}" \
            --remove-label "pending-helix" \
            --add-label "status:rejected"

          echo "::notice::Issue #${ISSUE_NUMBER} cerrado como rechazado"

      # -----------------------------------------------------------------------
      # Paso 3b: APROBADO - Cargar configuración del subdominio
      # -----------------------------------------------------------------------
      - name: Load Repo Config
        if: steps.validate.outputs.status == 'APPROVED'
        id: config
        run: |
          SUBDOMINIO="${{ steps.find-request.outputs.subdominio }}"

          if [ ! -f "${{ env.CONFIG_FILE }}" ]; then
            echo "::error::Archivo de configuración no encontrado: ${{ env.CONFIG_FILE }}"
            exit 1
          fi

          GIT_REPO=$(grep -A5 "^  ${SUBDOMINIO}:" "${{ env.CONFIG_FILE }}" | grep "git_repo:" | head -1 | awk '{print $2}')

          if [ -z "$GIT_REPO" ]; then
            echo "::error::Subdominio '${SUBDOMINIO}' no encontrado en configuración"
            exit 1
          fi

          echo "::notice::Target repo: ${GIT_REPO}"
          echo "git_repo=${GIT_REPO}" >> $GITHUB_OUTPUT

      # -----------------------------------------------------------------------
      # Paso 4: Descargar artifact del export de la API
      # -----------------------------------------------------------------------
      - name: Download API Export
        if: steps.validate.outputs.status == 'APPROVED'
        id: download
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          REQUEST_ID="${{ steps.validate.outputs.request_id }}"
          ARTIFACT_NAME="api-export-${REQUEST_ID}"
          mkdir -p ./api-export

          # Buscar y descargar artifact de runs recientes
          gh run list --workflow "process-api-request.yml" --limit 20 --json databaseId | jq -r '.[].databaseId' | while read RUN_ID; do
            if gh run download "${RUN_ID}" --name "${ARTIFACT_NAME}" --dir ./api-export 2>/dev/null; then
              echo "::notice::Artifact descargado del run ${RUN_ID}"
              break
            fi
          done

          if [ -z "$(ls -A ./api-export 2>/dev/null)" ]; then
            echo "::warning::No se pudo descargar artifact, se creará estructura mínima"
            echo "artifact_found=false" >> $GITHUB_OUTPUT
          else
            echo "artifact_found=true" >> $GITHUB_OUTPUT
            echo "Contenido descargado:"
            find ./api-export -type f
          fi

      # -----------------------------------------------------------------------
      # Paso 5: Crear PR en el repositorio de dominio (SIN REVISIONES)
      # -----------------------------------------------------------------------
      - name: Create PR in Subdominio Repo
        if: steps.validate.outputs.status == 'APPROVED'
        env:
          GH_TOKEN: ${{ secrets.SUBDOMINIO_PAT }}
        run: |
          API_NAME="${{ steps.find-request.outputs.api_name }}"
          API_VERSION="${{ steps.find-request.outputs.api_version }}"
          TARGET_REPO="${{ steps.config.outputs.git_repo }}"
          CRQ_ID="${{ steps.validate.outputs.crq_id }}"
          USER_ID="${{ steps.find-request.outputs.user_id }}"
          SUBDOMINIO="${{ steps.find-request.outputs.subdominio }}"
          REQUEST_ID="${{ steps.validate.outputs.request_id }}"
          BACKEND_URL="${{ steps.find-request.outputs.backend_url }}"
          ACTION="${{ steps.find-request.outputs.action }}"
          ENVIRONMENT="${{ steps.find-request.outputs.environment }}"

          # Extract short unique suffix from requestId
          REQ_SUFFIX=$(echo "${REQUEST_ID}" | rev | cut -d'-' -f1 | rev)

          # Branch name simplificado (sin revisión)
          BRANCH_NAME="api/${ENVIRONMENT}/${API_NAME}-${API_VERSION}-${REQ_SUFFIX}"

          echo "=========================================="
          echo "  Creating PR in ${TARGET_REPO}"
          echo "=========================================="
          echo "API: ${API_NAME} v${API_VERSION}"
          echo "Action: ${ACTION}"
          echo "Environment: ${ENVIRONMENT}"
          echo "Branch: ${BRANCH_NAME}"
          echo ""

          # Clone target repo
          git clone "https://x-access-token:${GH_TOKEN}@github.com/${TARGET_REPO}.git" target-repo
          cd target-repo

          # Configure git
          git config user.name "Helix-Processor Bot"
          git config user.email "helix-processor@github.actions"

          # Check if branch already exists
          if git ls-remote --exit-code --heads origin "${BRANCH_NAME}" > /dev/null 2>&1; then
            echo "Branch ${BRANCH_NAME} already exists (duplicate request)"
            EXISTING_PR=$(gh pr list --repo "${TARGET_REPO}" --head "${BRANCH_NAME}" --state all --json number,state --jq '.[0] | "\(.number) (\(.state))"')
            if [ -n "$EXISTING_PR" ]; then
              echo "PR ${EXISTING_PR} already exists - skipping"
              exit 0
            fi
            git push origin --delete "${BRANCH_NAME}" || true
          fi

          # Create branch
          git checkout -b "${BRANCH_NAME}"

          # =================================================================
          # ESTRUCTURA v3 - SIN REVISIONES
          # =================================================================
          # apis/{APIName}/
          #   state.yaml
          #   {Version}/
          #     api.yaml
          #     Definitions/swagger.yaml
          #     Conf/api_meta.yaml
          #     Conf/params.yaml
          #     Conf/request.yaml
          # =================================================================

          API_PATH="apis/${API_NAME}"
          VERSION_PATH="${API_PATH}/${API_VERSION}"

          # Crear estructura de directorios
          mkdir -p "${VERSION_PATH}/Definitions"
          mkdir -p "${VERSION_PATH}/Conf"

          # Copiar archivos del artifact si existe
          if [ -d "../api-export" ] && [ -n "$(ls -A ../api-export 2>/dev/null)" ]; then
            EXPORT_DIR=$(find ../api-export -type d -name "${API_NAME}-${API_VERSION}" | head -1)

            if [ -n "$EXPORT_DIR" ] && [ -d "$EXPORT_DIR" ]; then
              echo "Encontrado export en: $EXPORT_DIR"

              # Copiar api.json -> api.yaml
              if [ -f "${EXPORT_DIR}/api.json" ]; then
                cp "${EXPORT_DIR}/api.json" "${VERSION_PATH}/api.yaml"
                echo "✓ api.yaml"
              fi

              # Copiar swagger
              if [ -f "${EXPORT_DIR}/Definitions/swagger.json" ]; then
                cp "${EXPORT_DIR}/Definitions/swagger.json" "${VERSION_PATH}/Definitions/swagger.yaml"
                echo "✓ swagger.yaml"
              elif [ -f "${EXPORT_DIR}/Definitions/swagger.yaml" ]; then
                cp "${EXPORT_DIR}/Definitions/swagger.yaml" "${VERSION_PATH}/Definitions/swagger.yaml"
                echo "✓ swagger.yaml"
              fi

              # Copiar api_meta.yaml
              if [ -f "${EXPORT_DIR}/api_meta.yaml" ]; then
                cp "${EXPORT_DIR}/api_meta.yaml" "${VERSION_PATH}/Conf/api_meta.yaml"
                echo "✓ api_meta.yaml"
              fi
            else
              echo "No se encontró directorio de export, buscando archivos sueltos..."
              find ../api-export -name "api.json" -exec cp {} "${VERSION_PATH}/api.yaml" \; 2>/dev/null || true
              find ../api-export -name "swagger.json" -exec cp {} "${VERSION_PATH}/Definitions/swagger.yaml" \; 2>/dev/null || true
              find ../api-export -name "swagger.yaml" -exec cp {} "${VERSION_PATH}/Definitions/swagger.yaml" \; 2>/dev/null || true
              find ../api-export -name "api_meta.yaml" -exec cp {} "${VERSION_PATH}/Conf/api_meta.yaml" \; 2>/dev/null || true
            fi
          fi

          # Generar api_meta.yaml si no existe
          if [ ! -f "${VERSION_PATH}/Conf/api_meta.yaml" ]; then
            cat > "${VERSION_PATH}/Conf/api_meta.yaml" << EOF
deploy:
  import:
    preserveProvider: false
    rotateRevision: true
    update: true
name: ${API_NAME}
version: ${API_VERSION}
EOF
            echo "✓ api_meta.yaml (generado)"
          fi

          # Generar params.yaml con configuración multi-entorno
          cat > "${VERSION_PATH}/Conf/params.yaml" << EOF
# =============================================================================
# ${API_NAME} ${API_VERSION} - Configuración por Entorno
# =============================================================================
# Última actualización: $(date -u +%Y-%m-%dT%H:%M:%SZ)
# CRQ: ${CRQ_ID}
# =============================================================================

environments:
  # ---------------------------------------------------------------------------
  # UAT - Desarrollo/Testing
  # ---------------------------------------------------------------------------
  - name: uat
    configs:
      endpoints:
        production:
          url: ${BACKEND_URL:-https://api-uat.internal.company.com/placeholder}
          config:
            retryTimeOut: 2
            retryDelay: 500
            suspendDuration: 10000
            suspendMaxDuration: 30000

      security:
        production:
          enabled: false

      certs: []
      mutualSslCerts: []

      policies:
        - Gold

      deploymentEnvironments:
        - displayOnDevportal: true
          deploymentEnvironment: Default

  # ---------------------------------------------------------------------------
  # NFT - Pre-producción
  # ---------------------------------------------------------------------------
  - name: nft
    configs:
      endpoints:
        production:
          url: ${BACKEND_URL:-https://api-nft.internal.company.com/placeholder}
          config:
            retryTimeOut: 3
            retryDelay: 1000
            suspendDuration: 30000
            suspendMaxDuration: 60000

      security:
        production:
          enabled: false

      certs: []
      mutualSslCerts: []

      policies:
        - Platinum

      deploymentEnvironments:
        - displayOnDevportal: true
          deploymentEnvironment: Default

  # ---------------------------------------------------------------------------
  # PRO - Producción
  # ---------------------------------------------------------------------------
  - name: pro
    configs:
      endpoints:
        production:
          url: ${BACKEND_URL:-https://api.company.com/placeholder}
          config:
            retryTimeOut: 5
            retryDelay: 2000
            suspendDuration: 60000
            suspendMaxDuration: 300000

      security:
        production:
          enabled: false

      certs: []
      mutualSslCerts: []

      policies:
        - Unlimited

      deploymentEnvironments:
        - displayOnDevportal: true
          deploymentEnvironment: Default
EOF
          echo "✓ params.yaml"

          # Generar request.yaml (trazabilidad de la última solicitud)
          cat > "${VERSION_PATH}/Conf/request.yaml" << EOF
# =============================================================================
# Última solicitud de registro
# =============================================================================
# Este archivo se sobrescribe en cada registro
# =============================================================================

request_id: ${REQUEST_ID}
timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)
action: ${ACTION}
environment: ${ENVIRONMENT}
subdominio: ${SUBDOMINIO}

helix:
  crq_id: ${CRQ_ID}
  status: APPROVED

api:
  name: ${API_NAME}
  version: ${API_VERSION}

user: ${USER_ID}
approval_workflow: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
EOF
          echo "✓ request.yaml"

          # =================================================================
          # Crear/Actualizar state.yaml a nivel de API
          # =================================================================
          STATE_FILE="${API_PATH}/state.yaml"

          # Siempre recrear state.yaml con la info actual
          cat > "${STATE_FILE}" << EOF
# =============================================================================
# ${API_NAME} - Estado de Deployments por Entorno
# =============================================================================
# ARCHIVO AUTO-GENERADO por apim-apiops-controller
# Se actualiza en cada registro
# =============================================================================

api_name: ${API_NAME}
last_updated: $(date -u +%Y-%m-%dT%H:%M:%SZ)

environments:
  uat:
    version: ${API_VERSION}
    status: REGISTERED
    registered_at: $(date -u +%Y-%m-%dT%H:%M:%SZ)
    registered_by: ${USER_ID}
    helix_crq: ${CRQ_ID}

  nft:
    version: null
    status: NOT_DEPLOYED

  pro:
    version: null
    status: NOT_DEPLOYED

last_registration:
  request_id: ${REQUEST_ID}
  timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)
  api_version: ${API_VERSION}
  crq: ${CRQ_ID}
  user: ${USER_ID}
EOF
          echo "✓ state.yaml"

          # Mostrar estructura creada
          echo ""
          echo "Estructura creada/actualizada:"
          find "${API_PATH}" -type f | sort

          # Commit
          git add .
          COMMIT_MSG="feat(${API_NAME}): v${API_VERSION} - Helix Approved [${CRQ_ID}]

Action: ${ACTION}
Environment: ${ENVIRONMENT}
User: ${USER_ID}
Request: ${REQUEST_ID}"

          git commit -m "${COMMIT_MSG}" || echo "No changes to commit"

          # Push
          git push origin "${BRANCH_NAME}"

          # Create PR
          ENV_UPPER=$(echo "${ENVIRONMENT}" | tr '[:lower:]' '[:upper:]')
          PR_TITLE="${ENV_UPPER} DEPLOY: ${API_NAME} v${API_VERSION} [${CRQ_ID}]"

          PR_URL=$(gh pr create \
            --repo "${TARGET_REPO}" \
            --base "main" \
            --head "${BRANCH_NAME}" \
            --title "${PR_TITLE}" \
            --body "$(cat <<EOF
## API Registration - Helix APPROVED

| Campo | Valor |
|-------|-------|
| API | ${API_NAME} |
| Version | ${API_VERSION} |
| Environment | ${ENVIRONMENT} |
| Action | ${ACTION} |
| Subdominio | ${SUBDOMINIO} |
| Helix CRQ | ${CRQ_ID} |
| Estado | **APPROVED** |
| Solicitante | ${USER_ID} |
| Request ID | ${REQUEST_ID} |

### Estructura
\`\`\`
apis/${API_NAME}/
  state.yaml
  ${API_VERSION}/
    api.yaml
    Definitions/swagger.yaml
    Conf/
      api_meta.yaml
      params.yaml
      request.yaml
\`\`\`

---
Aprobado por Helix ITSM - Auto-merged by Helix-Processor
EOF
          )")

          echo "PR created: ${PR_URL}"

          # Merge inmediato
          echo "Merging PR..."
          if gh pr merge "${BRANCH_NAME}" --repo "${TARGET_REPO}" --squash --delete-branch; then
            echo ""
            echo "=========================================="
            echo "  SUCCESS - PR Created and Merged"
            echo "  PR: ${PR_URL}"
            echo "=========================================="
          else
            echo ""
            echo "=========================================="
            echo "  WARNING - PR Created but merge failed"
            echo "  PR: ${PR_URL}"
            echo "  Manual merge may be required"
            echo "=========================================="
          fi

      # -----------------------------------------------------------------------
      # Paso 6: Cerrar Issue como aprobado
      # -----------------------------------------------------------------------
      - name: Close Issue as Approved
        if: steps.validate.outputs.status == 'APPROVED'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUMBER="${{ steps.find-request.outputs.issue_number }}"
          CRQ_ID="${{ steps.validate.outputs.crq_id }}"
          API_NAME="${{ steps.find-request.outputs.api_name }}"
          API_VERSION="${{ steps.find-request.outputs.api_version }}"
          ENVIRONMENT="${{ steps.find-request.outputs.environment }}"

          ENV_UPPER=$(echo "${ENVIRONMENT}" | tr '[:lower:]' '[:upper:]')

          gh issue close "${ISSUE_NUMBER}" \
            --comment "## CRQ Approved and Processed

          | Campo | Valor |
          |-------|-------|
          | CRQ | ${CRQ_ID} |
          | API | ${API_NAME} v${API_VERSION} |
          | Environment | ${ENV_UPPER} |
          | Status | **APPROVED** |

          API registrada exitosamente. Estructura sin revisiones.
          PR creada y auto-merged."

          gh issue edit "${ISSUE_NUMBER}" \
            --remove-label "pending-helix" \
            --add-label "status:approved"

          echo "::notice::Issue #${ISSUE_NUMBER} cerrado como aprobado"

      - name: Summary
        run: |
          echo "## Helix Approval Processed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Campo | Valor |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| CRQ | ${{ steps.validate.outputs.crq_id }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Status | ${{ steps.validate.outputs.status }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Request ID | ${{ steps.validate.outputs.request_id }} |" >> $GITHUB_STEP_SUMMARY
          echo "| API | ${{ steps.find-request.outputs.api_name }} v${{ steps.find-request.outputs.api_version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ steps.find-request.outputs.environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Action | ${{ steps.find-request.outputs.action }} |" >> $GITHUB_STEP_SUMMARY
